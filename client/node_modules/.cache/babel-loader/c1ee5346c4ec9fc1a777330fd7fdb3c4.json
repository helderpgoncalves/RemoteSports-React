{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, env, image, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\n\nexport class WebcamIterator extends LazyIterator {\n  constructor(webcamVideoElement, webcamConfig) {\n    super();\n    this.webcamVideoElement = webcamVideoElement;\n    this.webcamConfig = webcamConfig;\n    this.isClosed = true;\n    this.resize = false;\n\n    if (this.needToResize()) {\n      this.resize = true;\n      this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n      this.cropBoxInd = tensor1d([0], 'int32');\n\n      if (this.webcamConfig.centerCrop) {\n        // Calculate the box based on resizing shape.\n        const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n        const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 / this.webcamVideoElement.height;\n        const widthCropStart = (1 - widthCroppingRatio) / 2;\n        const heightCropStart = (1 - heightCroppingRatio) / 2;\n        const widthCropEnd = widthCropStart + widthCroppingRatio;\n        const heightCropEnd = heightCroppingRatio + heightCropStart;\n        this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n      } else {\n        this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n  }\n\n  summary() {\n    return `webcam`;\n  } // Construct a WebcamIterator and start it's video stream.\n\n\n  static async create(webcamVideoElement, webcamConfig = {}) {\n    if (env().get('IS_NODE')) {\n      throw new Error('tf.data.webcam is only supported in browser environment.');\n    }\n\n    if (!webcamVideoElement) {\n      // If webcam video element is not provided, create a hidden video element\n      // with provided width and height.\n      webcamVideoElement = document.createElement('video');\n\n      if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n        throw new Error('Please provide webcam video element, or resizeWidth and ' + 'resizeHeight to create a hidden video element.');\n      }\n\n      webcamVideoElement.width = webcamConfig.resizeWidth;\n      webcamVideoElement.height = webcamConfig.resizeHeight;\n    }\n\n    const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig); // Call async function to initialize the video stream.\n\n    await webcamIterator.start();\n    return webcamIterator;\n  } // Async function to start video stream.\n\n\n  async start() {\n    if (this.webcamConfig.facingMode) {\n      util.assert(this.webcamConfig.facingMode === 'user' || this.webcamConfig.facingMode === 'environment', () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` + `Please provide 'user' or 'environment'`);\n    }\n\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          deviceId: this.webcamConfig.deviceId,\n          facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : 'user',\n          width: this.webcamVideoElement.width,\n          height: this.webcamVideoElement.height\n        }\n      });\n    } catch (e) {\n      // Modify the error message but leave the stack trace intact\n      e.message = `Error thrown while initializing video stream: ${e.message}`;\n      throw e;\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain video from webcam.');\n    } // Older browsers may not have srcObject\n\n\n    try {\n      this.webcamVideoElement.srcObject = this.stream;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n    } // Start the webcam video stream\n\n\n    this.webcamVideoElement.play();\n    this.isClosed = false;\n    return new Promise(resolve => {\n      // Add event listener to make sure the webcam has been fully initialized.\n      this.webcamVideoElement.onloadedmetadata = () => {\n        resolve();\n      };\n    });\n  }\n\n  async next() {\n    if (this.isClosed) {\n      return {\n        value: null,\n        done: true\n      };\n    }\n\n    let img;\n\n    try {\n      img = browser.fromPixels(this.webcamVideoElement);\n    } catch (e) {\n      throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n    }\n\n    if (this.resize) {\n      try {\n        return {\n          value: this.cropAndResizeFrame(img),\n          done: false\n        };\n      } catch (e) {\n        throw new Error(`Error thrown cropping the video: ${e.message}`);\n      } finally {\n        img.dispose();\n      }\n    } else {\n      return {\n        value: img,\n        done: false\n      };\n    }\n  }\n\n  needToResize() {\n    // If resizeWidth and resizeHeight are provided, and different from the\n    // width and height of original HTMLVideoElement, then resizing and cropping\n    // is required.\n    if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n      return true;\n    }\n\n    return false;\n  } // Cropping and resizing each frame based on config\n\n\n  cropAndResizeFrame(img) {\n    return tidy(() => {\n      const expandedImage = img.toFloat().expandDims(0);\n      let resizedImage;\n      resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear'); // Extract image from batch cropping.\n\n      const shape = resizedImage.shape;\n      return resizedImage.reshape(shape.slice(1));\n    });\n  } // Capture one frame from the video stream, and extract the value from\n  // iterator.next() result.\n\n\n  async capture() {\n    return (await this.next()).value;\n  } // Stop the video stream and pause webcam iterator.\n\n\n  stop() {\n    const tracks = this.stream.getTracks();\n    tracks.forEach(track => track.stop());\n\n    try {\n      this.webcamVideoElement.srcObject = null;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = null;\n    }\n\n    this.isClosed = true;\n  } // Override toArray() function to prevent collecting.\n\n\n  toArray() {\n    throw new Error('Can not convert infinite video stream to array.');\n  }\n\n}","map":{"version":3,"sources":["../../src/iterators/webcam_iterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, env, image, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\nexport class WebcamIterator extends LazyIterator {\n    constructor(webcamVideoElement, webcamConfig) {\n        super();\n        this.webcamVideoElement = webcamVideoElement;\n        this.webcamConfig = webcamConfig;\n        this.isClosed = true;\n        this.resize = false;\n        if (this.needToResize()) {\n            this.resize = true;\n            this.cropSize =\n                [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n            this.cropBoxInd = tensor1d([0], 'int32');\n            if (this.webcamConfig.centerCrop) {\n                // Calculate the box based on resizing shape.\n                const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n                const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 /\n                    this.webcamVideoElement.height;\n                const widthCropStart = (1 - widthCroppingRatio) / 2;\n                const heightCropStart = (1 - heightCroppingRatio) / 2;\n                const widthCropEnd = widthCropStart + widthCroppingRatio;\n                const heightCropEnd = heightCroppingRatio + heightCropStart;\n                this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n            }\n            else {\n                this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n            }\n        }\n    }\n    summary() {\n        return `webcam`;\n    }\n    // Construct a WebcamIterator and start it's video stream.\n    static async create(webcamVideoElement, webcamConfig = {}) {\n        if (env().get('IS_NODE')) {\n            throw new Error('tf.data.webcam is only supported in browser environment.');\n        }\n        if (!webcamVideoElement) {\n            // If webcam video element is not provided, create a hidden video element\n            // with provided width and height.\n            webcamVideoElement = document.createElement('video');\n            if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n                throw new Error('Please provide webcam video element, or resizeWidth and ' +\n                    'resizeHeight to create a hidden video element.');\n            }\n            webcamVideoElement.width = webcamConfig.resizeWidth;\n            webcamVideoElement.height = webcamConfig.resizeHeight;\n        }\n        const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);\n        // Call async function to initialize the video stream.\n        await webcamIterator.start();\n        return webcamIterator;\n    }\n    // Async function to start video stream.\n    async start() {\n        if (this.webcamConfig.facingMode) {\n            util.assert((this.webcamConfig.facingMode === 'user') ||\n                (this.webcamConfig.facingMode === 'environment'), () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` +\n                `Please provide 'user' or 'environment'`);\n        }\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    deviceId: this.webcamConfig.deviceId,\n                    facingMode: this.webcamConfig.facingMode ?\n                        this.webcamConfig.facingMode :\n                        'user',\n                    width: this.webcamVideoElement.width,\n                    height: this.webcamVideoElement.height\n                }\n            });\n        }\n        catch (e) {\n            // Modify the error message but leave the stack trace intact\n            e.message = `Error thrown while initializing video stream: ${e.message}`;\n            throw e;\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain video from webcam.');\n        }\n        // Older browsers may not have srcObject\n        try {\n            this.webcamVideoElement.srcObject = this.stream;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n        }\n        // Start the webcam video stream\n        this.webcamVideoElement.play();\n        this.isClosed = false;\n        return new Promise(resolve => {\n            // Add event listener to make sure the webcam has been fully initialized.\n            this.webcamVideoElement.onloadedmetadata = () => {\n                resolve();\n            };\n        });\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let img;\n        try {\n            img = browser.fromPixels(this.webcamVideoElement);\n        }\n        catch (e) {\n            throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n        }\n        if (this.resize) {\n            try {\n                return { value: this.cropAndResizeFrame(img), done: false };\n            }\n            catch (e) {\n                throw new Error(`Error thrown cropping the video: ${e.message}`);\n            }\n            finally {\n                img.dispose();\n            }\n        }\n        else {\n            return { value: img, done: false };\n        }\n    }\n    needToResize() {\n        // If resizeWidth and resizeHeight are provided, and different from the\n        // width and height of original HTMLVideoElement, then resizing and cropping\n        // is required.\n        if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight &&\n            (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth ||\n                this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n            return true;\n        }\n        return false;\n    }\n    // Cropping and resizing each frame based on config\n    cropAndResizeFrame(img) {\n        return tidy(() => {\n            const expandedImage = img.toFloat().expandDims(0);\n            let resizedImage;\n            resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear');\n            // Extract image from batch cropping.\n            const shape = resizedImage.shape;\n            return resizedImage.reshape(shape.slice(1));\n        });\n    }\n    // Capture one frame from the video stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    // Stop the video stream and pause webcam iterator.\n    stop() {\n        const tracks = this.stream.getTracks();\n        tracks.forEach(track => track.stop());\n        try {\n            this.webcamVideoElement.srcObject = null;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = null;\n        }\n        this.isClosed = true;\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite video stream to array.');\n    }\n}\n//# sourceMappingURL=webcam_iterator.js.map"]},"metadata":{},"sourceType":"module"}