{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\n\nexport var ModelLoggingVerbosity;\n\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\n\n\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\n\nexport class BaseCallback {\n  constructor() {\n    // TODO(michaelterry): This type is a best guess.\n    this.validationData = null;\n  }\n\n  setParams(params) {\n    this.params = params;\n  }\n\n  async onEpochBegin(epoch, logs) {}\n\n  async onEpochEnd(epoch, logs) {}\n\n  async onBatchBegin(batch, logs) {}\n\n  async onBatchEnd(batch, logs) {}\n\n  async onTrainBegin(logs) {}\n\n  async onTrainEnd(logs) {} // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n\n\n  setModel(model) {// Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n\n}\n/**\n * Container abstracting a list of callbacks.\n */\n\nexport class CallbackList {\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks, queueLength = 10) {\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback) {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params) {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model) {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onEpochBegin(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onEpochBegin(epoch, logs);\n    }\n  }\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onEpochEnd(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onEpochEnd(epoch, logs);\n    }\n  }\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onBatchBegin(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onBatchBegin(batch, logs);\n    }\n  }\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onBatchEnd(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onBatchEnd(batch, logs);\n    }\n  }\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onTrainBegin(logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onTrainBegin(logs);\n    }\n  }\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onTrainEnd(logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onTrainEnd(logs);\n    }\n  }\n\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\n\nexport class BaseLogger extends BaseCallback {\n  constructor() {\n    super();\n  }\n\n  async onEpochBegin(epoch) {\n    this.seen = 0;\n    this.totals = {};\n  }\n\n  async onBatchEnd(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    const batchSize = logs['size'] == null ? 0 : logs['size'];\n    this.seen += batchSize;\n\n    for (const key in logs) {\n      const value = logs[key];\n\n      if (typeof value === 'number') {\n        if (!this.totals.hasOwnProperty(key)) {\n          this.totals[key] = 0;\n        }\n\n        this.totals[key] = this.totals[key] + value * batchSize;\n      } else {\n        let oldTotalsToDispose;\n\n        if (key in this.totals) {\n          oldTotalsToDispose = this.totals[key];\n        } else {\n          this.totals[key] = 0;\n        }\n\n        const total = tidy(() => add(this.totals[key], mul(value, batchSize)));\n        this.totals[key] = total;\n\n        if (oldTotalsToDispose != null) {\n          oldTotalsToDispose.dispose();\n        }\n      }\n    }\n  }\n\n  async onEpochEnd(epoch, logs) {\n    if (logs != null) {\n      for (const key of this.params['metrics']) {\n        if (this.totals[key] == null) {\n          continue;\n        }\n\n        if (typeof this.totals[key] === 'number') {\n          logs[key] = this.totals[key] / this.seen;\n        } else {\n          tidy(() => {\n            const log = mul(div(1, this.seen), this.totals[key]);\n            logs[key] = log;\n            this.totals[key].dispose();\n            keep(logs[key]);\n          });\n        }\n      }\n    }\n  }\n\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\n\nexport class History extends BaseCallback {\n  async onTrainBegin(logs) {\n    this.epoch = [];\n    this.history = {};\n  }\n\n  async onEpochEnd(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    this.epoch.push(epoch);\n\n    for (const key in logs) {\n      if (this.history[key] == null) {\n        this.history[key] = [];\n      }\n\n      this.history[key].push(logs[key]);\n    }\n  }\n  /**\n   * Await the values of all losses and metrics.\n   */\n\n\n  async syncData() {\n    const promises = [];\n    const keys = [];\n    const indices = [];\n\n    for (const key in this.history) {\n      const valueArray = this.history[key];\n\n      for (let i = 0; i < valueArray.length; ++i) {\n        if (typeof valueArray[i] !== 'number') {\n          const valueScalar = valueArray[i];\n          promises.push(valueScalar.data());\n          keys.push(key);\n          indices.push(i);\n        }\n      }\n    }\n\n    const values = await Promise.all(promises);\n\n    for (let n = 0; n < values.length; ++n) {\n      const tensorToDispose = this.history[keys[n]][indices[n]];\n      tensorToDispose.dispose();\n      this.history[keys[n]][indices[n]] = values[n][0];\n    }\n  }\n\n}\n/**\n * Custom callback for training.\n */\n\nexport class CustomCallback extends BaseCallback {\n  constructor(args, yieldEvery) {\n    super();\n    this.currentEpoch = 0;\n    this.yieldEvery = yieldEvery || 'auto';\n\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery);\n    }\n\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  async maybeWait(epoch, batch, logs) {\n    const ps = [];\n\n    if (this.yield != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.yield(epoch, batch, logs));\n    }\n\n    ps.push(nextFrame());\n    await Promise.all(ps);\n  }\n\n  async onEpochBegin(epoch, logs) {\n    this.currentEpoch = epoch;\n\n    if (this.epochBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.epochBegin(epoch, logs);\n    }\n  }\n\n  async onEpochEnd(epoch, logs) {\n    const ps = [];\n\n    if (this.epochEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.epochEnd(epoch, logs));\n    }\n\n    if (this.yieldEvery === 'epoch') {\n      ps.push(nextFrame());\n    }\n\n    await Promise.all(ps);\n  }\n\n  async onBatchBegin(batch, logs) {\n    if (this.batchBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.batchBegin(batch, logs);\n    }\n  }\n\n  async onBatchEnd(batch, logs) {\n    const ps = [];\n\n    if (this.batchEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.batchEnd(batch, logs));\n    }\n\n    if (this.yieldEvery === 'batch') {\n      ps.push(nextFrame());\n    } else if (util.isNumber(this.yieldEvery)) {\n      ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n    }\n\n    await Promise.all(ps);\n  }\n\n  async onTrainBegin(logs) {\n    if (this.trainBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainBegin(logs);\n    }\n  }\n\n  async onTrainEnd(logs) {\n    if (this.trainEnd != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainEnd(logs);\n    }\n  }\n\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\n\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  } // Convert custom callback configs to custom callback objects.\n\n\n  const callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\n\nexport class CallbackConstructorRegistry {\n  /**\n   * Blocks public access to constructor.\n   */\n  constructor() {}\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n\n\n  static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n    util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` + `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n  }\n\n  static checkForDuplicate(callbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n  /**\n   * Clear all registered callback constructors.\n   */\n\n\n  static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n\n\n  static createCallbacks(verbosityLevel) {\n    const constructors = [];\n\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n\n    return constructors.map(ctor => new ctor());\n  }\n\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  const history = new History();\n  const actualCallbacks = [new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)];\n\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks); // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList,\n    history\n  };\n}","map":{"version":3,"sources":["../src/base_callbacks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport class BaseCallback {\n    constructor() {\n        // TODO(michaelterry): This type is a best guess.\n        this.validationData = null;\n    }\n    setParams(params) {\n        this.params = params;\n    }\n    async onEpochBegin(epoch, logs) { }\n    async onEpochEnd(epoch, logs) { }\n    async onBatchBegin(batch, logs) { }\n    async onBatchEnd(batch, logs) { }\n    async onTrainBegin(logs) { }\n    async onTrainEnd(logs) { }\n    // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n    setModel(model) {\n        // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n}\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n    // TODO(cais): When the need arises, uncomment the following lines and\n    // implement the queue for time values.\n    // private deltaTBatch: number;\n    // private deltaTsBatchBegin: Array<number>;\n    // private deltaTsBatchEnd: Array<number>;\n    /**\n     * Constructor of CallbackList.\n     * @param callbacks Array of `Callback` instances.\n     * @param queueLength Queue length for keeping running statistics over\n     *   callback execution time.\n     */\n    constructor(callbacks, queueLength = 10) {\n        // TODO(cais): Make use of queueLength when implementing the queue for time\n        // values.\n        if (callbacks == null) {\n            callbacks = [];\n        }\n        this.callbacks = callbacks;\n        this.queueLength = queueLength;\n    }\n    append(callback) {\n        this.callbacks.push(callback);\n    }\n    setParams(params) {\n        for (const callback of this.callbacks) {\n            callback.setParams(params);\n        }\n    }\n    setModel(model) {\n        for (const callback of this.callbacks) {\n            callback.setModel(model);\n        }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochBegin(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochBegin(epoch, logs);\n        }\n    }\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochEnd(epoch, logs);\n        }\n    }\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchBegin(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchBegin(batch, logs);\n        }\n    }\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchEnd(batch, logs);\n        }\n    }\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainBegin(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainBegin(logs);\n        }\n    }\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainEnd(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainEnd(logs);\n        }\n    }\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n    constructor() {\n        super();\n    }\n    async onEpochBegin(epoch) {\n        this.seen = 0;\n        this.totals = {};\n    }\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        const batchSize = logs['size'] == null ? 0 : logs['size'];\n        this.seen += batchSize;\n        for (const key in logs) {\n            const value = logs[key];\n            if (typeof value === 'number') {\n                if (!this.totals.hasOwnProperty(key)) {\n                    this.totals[key] = 0;\n                }\n                this.totals[key] = this.totals[key] + value * batchSize;\n            }\n            else {\n                let oldTotalsToDispose;\n                if (key in this.totals) {\n                    oldTotalsToDispose = this.totals[key];\n                }\n                else {\n                    this.totals[key] = 0;\n                }\n                const total = tidy(() => add((this.totals[key]), mul(value, batchSize)));\n                this.totals[key] = total;\n                if (oldTotalsToDispose != null) {\n                    oldTotalsToDispose.dispose();\n                }\n            }\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs != null) {\n            for (const key of this.params['metrics']) {\n                if (this.totals[key] == null) {\n                    continue;\n                }\n                if (typeof this.totals[key] === 'number') {\n                    logs[key] = this.totals[key] / this.seen;\n                }\n                else {\n                    tidy(() => {\n                        const log = mul(div(1, this.seen), this.totals[key]);\n                        logs[key] = log;\n                        this.totals[key].dispose();\n                        keep(logs[key]);\n                    });\n                }\n            }\n        }\n    }\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n    async onTrainBegin(logs) {\n        this.epoch = [];\n        this.history = {};\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        this.epoch.push(epoch);\n        for (const key in logs) {\n            if (this.history[key] == null) {\n                this.history[key] = [];\n            }\n            this.history[key].push(logs[key]);\n        }\n    }\n    /**\n     * Await the values of all losses and metrics.\n     */\n    async syncData() {\n        const promises = [];\n        const keys = [];\n        const indices = [];\n        for (const key in this.history) {\n            const valueArray = this.history[key];\n            for (let i = 0; i < valueArray.length; ++i) {\n                if (typeof valueArray[i] !== 'number') {\n                    const valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                }\n            }\n        }\n        const values = await Promise.all(promises);\n        for (let n = 0; n < values.length; ++n) {\n            const tensorToDispose = this.history[keys[n]][indices[n]];\n            tensorToDispose.dispose();\n            this.history[keys[n]][indices[n]] = values[n][0];\n        }\n    }\n}\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n    constructor(args, yieldEvery) {\n        super();\n        this.currentEpoch = 0;\n        this.yieldEvery = yieldEvery || 'auto';\n        if (this.yieldEvery === 'auto') {\n            this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n        }\n        if (this.yieldEvery === 'never' && args.onYield != null) {\n            throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' +\n                'Either change `yieldEvery` or remove the callback');\n        }\n        if (util.isNumber(this.yieldEvery)) {\n            // Decorate `maybeWait` so it will be called at most once every\n            // `yieldEvery` ms.\n            this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery);\n        }\n        this.trainBegin = args.onTrainBegin;\n        this.trainEnd = args.onTrainEnd;\n        this.epochBegin = args.onEpochBegin;\n        this.epochEnd = args.onEpochEnd;\n        this.batchBegin = args.onBatchBegin;\n        this.batchEnd = args.onBatchEnd;\n        this.yield = args.onYield;\n    }\n    async maybeWait(epoch, batch, logs) {\n        const ps = [];\n        if (this.yield != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.yield(epoch, batch, logs));\n        }\n        ps.push(nextFrame());\n        await Promise.all(ps);\n    }\n    async onEpochBegin(epoch, logs) {\n        this.currentEpoch = epoch;\n        if (this.epochBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.epochBegin(epoch, logs);\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        const ps = [];\n        if (this.epochEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.epochEnd(epoch, logs));\n        }\n        if (this.yieldEvery === 'epoch') {\n            ps.push(nextFrame());\n        }\n        await Promise.all(ps);\n    }\n    async onBatchBegin(batch, logs) {\n        if (this.batchBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.batchBegin(batch, logs);\n        }\n    }\n    async onBatchEnd(batch, logs) {\n        const ps = [];\n        if (this.batchEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.batchEnd(batch, logs));\n        }\n        if (this.yieldEvery === 'batch') {\n            ps.push(nextFrame());\n        }\n        else if (util.isNumber(this.yieldEvery)) {\n            ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n        }\n        await Promise.all(ps);\n    }\n    async onTrainBegin(logs) {\n        if (this.trainBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainBegin(logs);\n        }\n    }\n    async onTrainEnd(logs) {\n        if (this.trainEnd != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainEnd(logs);\n        }\n    }\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n    if (callbacks == null) {\n        callbacks = {};\n    }\n    if (callbacks instanceof BaseCallback) {\n        return [callbacks];\n    }\n    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n        return callbacks;\n    }\n    // Convert custom callback configs to custom callback objects.\n    const callbackConfigs = generic_utils.toList(callbacks);\n    return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n    /**\n     * Blocks public access to constructor.\n     */\n    constructor() { }\n    /**\n     * Register a tf.LayersModel.fit() callback constructor.\n     *\n     * The registered callback constructor will be used to instantiate\n     * callbacks for every tf.LayersModel.fit() call afterwards.\n     *\n     * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n     *   is to be reigstered.\n     * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n     * @throws Error, if the same callbackConstructor has been registered before,\n     *   either at the same or a different `verbosityLevel`.\n     */\n    static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n        util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n            CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n        }\n        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n    static checkForDuplicate(callbackConstructor) {\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const constructors = CallbackConstructorRegistry.constructors[+levelName];\n            constructors.forEach(ctor => {\n                if (ctor === callbackConstructor) {\n                    throw new ValueError('Duplicate callback constructor.');\n                }\n            });\n        }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n    static clear() {\n        CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n    static createCallbacks(verbosityLevel) {\n        const constructors = [];\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const level = +levelName;\n            if (verbosityLevel >= level) {\n                constructors.push(...CallbackConstructorRegistry.constructors[level]);\n            }\n        }\n        return constructors.map(ctor => new ctor());\n    }\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n    const history = new History();\n    const actualCallbacks = [\n        new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n    ];\n    if (callbacks != null) {\n        actualCallbacks.push(...callbacks);\n    }\n    actualCallbacks.push(history);\n    const callbackList = new CallbackList(actualCallbacks);\n    // TODO(cais): Figure out when this LayersModel instance can have a\n    // dynamically\n    //   set property called 'callback_model' as in PyKeras.\n    callbackList.setParams({\n        epochs,\n        initialEpoch,\n        samples: numTrainSamples,\n        steps: stepsPerEpoch,\n        batchSize,\n        verbose,\n        doValidation,\n        metrics: callbackMetrics,\n    });\n    return { callbackList, history };\n}\n//# sourceMappingURL=base_callbacks.js.map"]},"metadata":{},"sourceType":"module"}